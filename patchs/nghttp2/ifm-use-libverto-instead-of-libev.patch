From df0fc1f9ed617f19c9bfdf374c7165af838e4178 Mon Sep 17 00:00:00 2001
From: huangduirong <huangduirong@huawei.com>
Date: Sun, 5 Nov 2023 10:26:12 +0800
Subject: [PATCH] ifm use libverto instead of libev

---
 src/HttpServer.cc           | 280 +++++++++++++++++-------------------
 src/HttpServer.h            |  32 +++--
 src/h2load.cc               | 238 ++++++++++++------------------
 src/h2load.h                |  37 ++---
 src/h2load_http2_session.cc |   9 +-
 src/h2load_quic.cc          |  22 ++-
 src/h2load_quic.h           |   6 +-
 src/nghttp.cc               | 194 ++++++++++---------------
 src/nghttp.h                |  39 ++---
 9 files changed, 383 insertions(+), 474 deletions(-)

diff --git a/src/HttpServer.cc b/src/HttpServer.cc
index dac18a8..5207f4d 100644
--- a/src/HttpServer.cc
+++ b/src/HttpServer.cc
@@ -1,4 +1,4 @@
-/*
+ /*
  * nghttp2 - HTTP/2 C Library
  *
  * Copyright (c) 2013 Tatsuhiro Tsujikawa
@@ -67,6 +67,7 @@
 #include "util.h"
 #include "tls.h"
 #include "template.h"
+#include <time.h>
 
 #ifndef O_BINARY
 #  define O_BINARY (0)
@@ -96,8 +97,8 @@ void print_session_id(int64_t id) { std::cout << "[id=" << id << "] "; }
 
 Config::Config()
     : mime_types_file("/etc/mime.types"),
-      stream_read_timeout(1_min),
-      stream_write_timeout(1_min),
+      verto_stream_read_timeout(1_min),
+      verto_stream_write_timeout(1_min),
       data_ptr(nullptr),
       padding(0),
       num_worker(1),
@@ -122,15 +123,12 @@ Config::Config()
 Config::~Config() {}
 
 namespace {
-void stream_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents) {
+void verto_stream_timeout_cb(verto_ctx *verto_loop, verto_ev *ev) {
   int rv;
-  auto stream = static_cast<Stream *>(w->data);
+  auto stream = static_cast<Stream *>(verto_get_private(ev));
   auto hd = stream->handler;
   auto config = hd->get_config();
 
-  ev_timer_stop(hd->get_loop(), &stream->rtimer);
-  ev_timer_stop(hd->get_loop(), &stream->wtimer);
-
   if (config->verbose) {
     print_session_id(hd->session_id());
     print_timer();
@@ -149,37 +147,41 @@ void stream_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents) {
 namespace {
 void add_stream_read_timeout(Stream *stream) {
   auto hd = stream->handler;
-  ev_timer_again(hd->get_loop(), &stream->rtimer);
+  auto config = hd->get_config();
+  stream->verto_rtimer = verto_add_timeout(hd->get_loop(), VERTO_EV_FLAG_PERSIST, verto_stream_timeout_cb, config->verto_stream_read_timeout * 1000);
+  verto_set_private(stream->verto_rtimer, stream, NULL);
 }
 } // namespace
 
 namespace {
 void add_stream_read_timeout_if_pending(Stream *stream) {
   auto hd = stream->handler;
-  if (ev_is_active(&stream->rtimer)) {
-    ev_timer_again(hd->get_loop(), &stream->rtimer);
-  }
+  auto config = hd->get_config();
+  stream->verto_rtimer = verto_add_timeout(hd->get_loop(), VERTO_EV_FLAG_PERSIST, verto_stream_timeout_cb, config->verto_stream_read_timeout * 1000);
+  verto_set_private(stream->verto_rtimer, stream, NULL);
 }
 } // namespace
 
 namespace {
 void add_stream_write_timeout(Stream *stream) {
   auto hd = stream->handler;
-  ev_timer_again(hd->get_loop(), &stream->wtimer);
+  auto config = hd->get_config();
+  stream->verto_wtimer = verto_add_timeout(hd->get_loop(), VERTO_EV_FLAG_PERSIST, verto_stream_timeout_cb, config->verto_stream_write_timeout * 1000);
+  verto_set_private(stream->verto_wtimer, stream, NULL);
 }
 } // namespace
 
 namespace {
 void remove_stream_read_timeout(Stream *stream) {
   auto hd = stream->handler;
-  ev_timer_stop(hd->get_loop(), &stream->rtimer);
+  verto_del(stream->verto_rtimer);
 }
 } // namespace
 
 namespace {
 void remove_stream_write_timeout(Stream *stream) {
   auto hd = stream->handler;
-  ev_timer_stop(hd->get_loop(), &stream->wtimer);
+  verto_del(stream->verto_wtimer);
 }
 } // namespace
 
@@ -188,11 +190,11 @@ void fill_callback(nghttp2_session_callbacks *callbacks, const Config *config);
 } // namespace
 
 namespace {
-constexpr ev_tstamp RELEASE_FD_TIMEOUT = 2.;
+constexpr double RELEASE_FD_TIMEOUT = 2.;
 } // namespace
 
 namespace {
-void release_fd_cb(struct ev_loop *loop, ev_timer *w, int revents);
+void verto_release_fd_cb(verto_ctx *verto_loop, verto_ev *ev);
 } // namespace
 
 namespace {
@@ -234,19 +236,31 @@ bool validate_file_entry(FileEntry *ent,
 }
 } // namespace
 
+namespace {
+double getCurrentTimeInSeconds() {
+  struct timespec ts;
+  clock_gettime(CLOCK_REALTIME, &ts);
+
+   // 计算time_t类型的时间戳，以秒为单位
+  double timestamp = (double)ts.tv_sec + (double)ts.tv_nsec / 1.0e9;
+
+  return timestamp;
+  }
+}
+
 class Sessions {
 public:
-  Sessions(HttpServer *sv, struct ev_loop *loop, const Config *config,
+  Sessions(HttpServer *sv, verto_ctx *verto_loop, const Config *config,
            SSL_CTX *ssl_ctx)
       : sv_(sv),
-        loop_(loop),
+        verto_loop_(verto_loop),
         config_(config),
         ssl_ctx_(ssl_ctx),
         callbacks_(nullptr),
         option_(nullptr),
         next_session_id_(1),
-        tstamp_cached_(ev_now(loop)),
-        cached_date_(util::http_date(tstamp_cached_)) {
+        verto_tstamp_cached_(getCurrentTimeInSeconds()),
+        cached_date_(util::http_date((long)verto_tstamp_cached_)) {
     nghttp2_session_callbacks_new(&callbacks_);
 
     fill_callback(callbacks_, config_);
@@ -257,26 +271,30 @@ public:
       nghttp2_option_set_max_deflate_dynamic_table_size(
           option_, config_->encoder_header_table_size);
     }
-
-    ev_timer_init(&release_fd_timer_, release_fd_cb, 0., RELEASE_FD_TIMEOUT);
-    release_fd_timer_.data = this;
   }
+
   ~Sessions() {
-    ev_timer_stop(loop_, &release_fd_timer_);
+    verto_del(verto_release_fd_timer_);
     for (auto handler : handlers_) {
       delete handler;
     }
     nghttp2_option_del(option_);
     nghttp2_session_callbacks_del(callbacks_);
   }
+  
   void add_handler(Http2Handler *handler) { handlers_.insert(handler); }
+
   void remove_handler(Http2Handler *handler) {
     handlers_.erase(handler);
     if (handlers_.empty() && !fd_cache_.empty()) {
-      ev_timer_again(loop_, &release_fd_timer_);
+      // Add release_fd_timer to the event loop
+      verto_release_fd_timer_ = verto_add_timeout(verto_loop_, VERTO_EV_FLAG_PERSIST, verto_release_fd_cb, RELEASE_FD_TIMEOUT * 1000);
+      verto_set_private(verto_release_fd_timer_, this, NULL);
     }
   }
+
   SSL_CTX *get_ssl_ctx() const { return ssl_ctx_; }
+  
   SSL *ssl_session_new(int fd) {
     SSL *ssl = SSL_new(ssl_ctx_);
     if (!ssl) {
@@ -290,10 +308,13 @@ public:
     }
     return ssl;
   }
+  
   const Config *get_config() const { return config_; }
-  struct ev_loop *get_loop() const {
-    return loop_;
+  
+  verto_ctx *get_loop() const {
+    return verto_loop_;
   }
+  
   int64_t get_next_session_id() {
     auto session_id = next_session_id_;
     if (next_session_id_ == std::numeric_limits<int64_t>::max()) {
@@ -303,8 +324,11 @@ public:
     }
     return session_id;
   }
+  
   const nghttp2_session_callbacks *get_callbacks() const { return callbacks_; }
+  
   const nghttp2_option *get_option() const { return option_; }
+  
   void accept_connection(int fd) {
     util::make_socket_nodelay(fd);
     SSL *ssl = nullptr;
@@ -324,21 +348,18 @@ public:
     }
     add_handler(handler.release());
   }
-  void update_cached_date() { cached_date_ = util::http_date(tstamp_cached_); }
+ 
+  void update_cached_date() { cached_date_ = util::http_date(verto_tstamp_cached_); }
+  
   const std::string &get_cached_date() {
-    auto t = ev_now(loop_);
-    if (t != tstamp_cached_) {
-      tstamp_cached_ = t;
-      update_cached_date();
-    }
     return cached_date_;
   }
+  
   FileEntry *get_cached_fd(const std::string &path) {
     auto range = fd_cache_.equal_range(path);
     if (range.first == range.second) {
       return nullptr;
     }
-
     auto now = std::chrono::steady_clock::now();
 
     for (auto it = range.first; it != range.second;) {
@@ -367,6 +388,7 @@ public:
     }
     return nullptr;
   }
+  
   FileEntry *cache_fd(const std::string &path, const FileEntry &ent) {
 #ifdef HAVE_STD_MAP_EMPLACE
     auto rv = fd_cache_.emplace(path, std::make_unique<FileEntry>(ent));
@@ -391,6 +413,7 @@ public:
 
     return res.get();
   }
+  
   void release_fd(FileEntry *target) {
     --target->usecount;
 
@@ -404,6 +427,7 @@ public:
     // We use timer to close file descriptor and delete the entry from
     // cache.  The timer will be started when there is no handler.
   }
+  
   void release_unused_fd() {
     for (auto i = std::begin(fd_cache_); i != std::end(fd_cache_);) {
       auto &ent = (*i).second;
@@ -417,7 +441,9 @@ public:
       i = fd_cache_.erase(i);
     }
   }
+  
   const HttpServer *get_server() const { return sv_; }
+  
   bool handlers_empty() const { return handlers_.empty(); }
 
 private:
@@ -426,22 +452,23 @@ private:
   std::multimap<std::string, std::unique_ptr<FileEntry>> fd_cache_;
   DList<FileEntry> fd_cache_lru_;
   HttpServer *sv_;
-  struct ev_loop *loop_;
   const Config *config_;
   SSL_CTX *ssl_ctx_;
   nghttp2_session_callbacks *callbacks_;
   nghttp2_option *option_;
-  ev_timer release_fd_timer_;
   int64_t next_session_id_;
-  ev_tstamp tstamp_cached_;
   std::string cached_date_;
+
+  verto_ctx *verto_loop_;
+  verto_ev *verto_release_fd_timer_;
+  double verto_tstamp_cached_;
 };
 
 namespace {
-void release_fd_cb(struct ev_loop *loop, ev_timer *w, int revents) {
-  auto sessions = static_cast<Sessions *>(w->data);
+void verto_release_fd_cb(verto_ctx *verto_loop, verto_ev *ev) {
+  auto sessions = static_cast<Sessions *>(verto_get_private(ev));
 
-  ev_timer_stop(loop, w);
+  verto_del(ev);
 
   if (!sessions->handlers_empty()) {
     return;
@@ -461,11 +488,6 @@ Stream::Stream(Http2Handler *handler, int32_t stream_id)
       header_buffer_size(0),
       stream_id(stream_id),
       echo_upload(false) {
-  auto config = handler->get_config();
-  ev_timer_init(&rtimer, stream_timeout_cb, 0., config->stream_read_timeout);
-  ev_timer_init(&wtimer, stream_timeout_cb, 0., config->stream_write_timeout);
-  rtimer.data = this;
-  wtimer.data = this;
 }
 
 Stream::~Stream() {
@@ -483,9 +505,9 @@ Stream::~Stream() {
   nghttp2_rcbuf_decref(rcbuf.ims);
   nghttp2_rcbuf_decref(rcbuf.expect);
 
-  auto loop = handler->get_loop();
-  ev_timer_stop(loop, &rtimer);
-  ev_timer_stop(loop, &wtimer);
+  // Remove the Stream's timeout
+  verto_del(verto_rtimer);
+  verto_del(verto_wtimer);
 }
 
 namespace {
@@ -499,9 +521,9 @@ void on_session_closed(Http2Handler *hd, int64_t session_id) {
 } // namespace
 
 namespace {
-void settings_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents) {
+void verto_settings_timeout_cb(verto_ctx *verto_loop, verto_ev *ev) {
   int rv;
-  auto hd = static_cast<Http2Handler *>(w->data);
+  auto hd = static_cast<Http2Handler *>(verto_get_private(ev));
   hd->terminate_session(NGHTTP2_SETTINGS_TIMEOUT);
   rv = hd->on_write();
   if (rv == -1) {
@@ -511,11 +533,11 @@ void settings_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents) {
 } // namespace
 
 namespace {
-void readcb(struct ev_loop *loop, ev_io *w, int revents) {
+void verto_writecb(verto_ctx *verto_loop, verto_ev *ev) {
   int rv;
-  auto handler = static_cast<Http2Handler *>(w->data);
+  auto handler = static_cast<Http2Handler *>(verto_get_private(ev));
 
-  rv = handler->on_read();
+  rv = handler->on_write();
   if (rv == -1) {
     delete_handler(handler);
   }
@@ -523,19 +545,18 @@ void readcb(struct ev_loop *loop, ev_io *w, int revents) {
 } // namespace
 
 namespace {
-void writecb(struct ev_loop *loop, ev_io *w, int revents) {
+void verto_readcb(verto_ctx *verto_loop, verto_ev *ev) {
   int rv;
-  auto handler = static_cast<Http2Handler *>(w->data);
-
-  rv = handler->on_write();
+  auto handler = static_cast<Http2Handler *>(verto_get_private(ev));
+  
+  rv = handler->on_read();
   if (rv == -1) {
     delete_handler(handler);
   }
 }
 } // namespace
 
-Http2Handler::Http2Handler(Sessions *sessions, int fd, SSL *ssl,
-                           int64_t session_id)
+Http2Handler::Http2Handler(Sessions *sessions, int fd, SSL *ssl, int64_t session_id)
     : session_id_(session_id),
       session_(nullptr),
       sessions_(sessions),
@@ -543,16 +564,17 @@ Http2Handler::Http2Handler(Sessions *sessions, int fd, SSL *ssl,
       data_pending_(nullptr),
       data_pendinglen_(0),
       fd_(fd) {
-  ev_timer_init(&settings_timerev_, settings_timeout_cb, 10., 0.);
-  ev_io_init(&wev_, writecb, fd, EV_WRITE);
-  ev_io_init(&rev_, readcb, fd, EV_READ);
+  auto verto_loop = sessions_->get_loop();
 
-  settings_timerev_.data = this;
-  wev_.data = this;
-  rev_.data = this;
+  // Add read event observers and write event observers to the event loop
+  verto_ev_flag read_flag = (verto_ev_flag)(VERTO_EV_FLAG_PERSIST | VERTO_EV_FLAG_IO_READ);
+  verto_ev_flag write_flag = (verto_ev_flag)(VERTO_EV_FLAG_PERSIST | VERTO_EV_FLAG_IO_WRITE);
 
-  auto loop = sessions_->get_loop();
-  ev_io_start(loop, &rev_);
+  verto_rev_ = verto_add_io(verto_loop, read_flag, verto_readcb, fd);
+  verto_wev_ = verto_add_io(verto_loop, write_flag, verto_writecb, fd);
+
+  verto_set_private(verto_rev_, this, NULL);
+  verto_set_private(verto_wev_, this, NULL);
 
   if (ssl) {
     SSL_set_accept_state(ssl);
@@ -572,10 +594,11 @@ Http2Handler::~Http2Handler() {
     ERR_clear_error();
     SSL_shutdown(ssl_);
   }
-  auto loop = sessions_->get_loop();
-  ev_timer_stop(loop, &settings_timerev_);
-  ev_io_stop(loop, &rev_);
-  ev_io_stop(loop, &wev_);
+  
+  // Remove read/write event observers listening on the current client
+  verto_del(verto_rev_);
+  verto_del(verto_wev_);
+
   if (ssl_) {
     SSL_free(ssl_);
   }
@@ -585,14 +608,17 @@ Http2Handler::~Http2Handler() {
 
 void Http2Handler::remove_self() { sessions_->remove_handler(this); }
 
-struct ev_loop *Http2Handler::get_loop() const {
+verto_ctx *Http2Handler::get_loop() {
+  // Get the event loop for the current session
   return sessions_->get_loop();
 }
 
 Http2Handler::WriteBuf *Http2Handler::get_wb() { return &wb_; }
 
 void Http2Handler::start_settings_timer() {
-  ev_timer_start(sessions_->get_loop(), &settings_timerev_);
+  verto_settings_timerev_ = verto_add_timeout(sessions_->get_loop(), VERTO_EV_FLAG_NONE, verto_settings_timeout_cb, 10 * 1000);
+  verto_set_private(verto_settings_timerev_, this, NULL);
+
 }
 
 int Http2Handler::fill_wb() {
@@ -665,7 +691,6 @@ int Http2Handler::read_clear() {
 }
 
 int Http2Handler::write_clear() {
-  auto loop = sessions_->get_loop();
   for (;;) {
     if (wb_.rleft() > 0) {
       ssize_t nwrite;
@@ -674,7 +699,6 @@ int Http2Handler::write_clear() {
         ;
       if (nwrite == -1) {
         if (errno == EAGAIN || errno == EWOULDBLOCK) {
-          ev_io_start(loop, &wev_);
           return 0;
         }
         return -1;
@@ -691,12 +715,6 @@ int Http2Handler::write_clear() {
     }
   }
 
-  if (wb_.rleft() == 0) {
-    ev_io_stop(loop, &wev_);
-  } else {
-    ev_io_start(loop, &wev_);
-  }
-
   if (nghttp2_session_want_read(session_) == 0 &&
       nghttp2_session_want_write(session_) == 0 && wb_.rleft() == 0) {
     return -1;
@@ -706,8 +724,6 @@ int Http2Handler::write_clear() {
 }
 
 int Http2Handler::tls_handshake() {
-  ev_io_stop(sessions_->get_loop(), &wev_);
-
   ERR_clear_error();
 
   auto rv = SSL_do_handshake(ssl_);
@@ -718,7 +734,6 @@ int Http2Handler::tls_handshake() {
     case SSL_ERROR_WANT_READ:
       return 0;
     case SSL_ERROR_WANT_WRITE:
-      ev_io_start(sessions_->get_loop(), &wev_);
       return 0;
     default:
       return -1;
@@ -788,8 +803,6 @@ int Http2Handler::read_tls() {
 }
 
 int Http2Handler::write_tls() {
-  auto loop = sessions_->get_loop();
-
   ERR_clear_error();
 
   for (;;) {
@@ -800,10 +813,8 @@ int Http2Handler::write_tls() {
         auto err = SSL_get_error(ssl_, rv);
         switch (err) {
         case SSL_ERROR_WANT_READ:
-          // renegotiation started
           return -1;
         case SSL_ERROR_WANT_WRITE:
-          ev_io_start(sessions_->get_loop(), &wev_);
           return 0;
         default:
           return -1;
@@ -822,12 +833,6 @@ int Http2Handler::write_tls() {
     }
   }
 
-  if (wb_.rleft() == 0) {
-    ev_io_stop(loop, &wev_);
-  } else {
-    ev_io_start(loop, &wev_);
-  }
-
   if (nghttp2_session_want_read(session_) == 0 &&
       nghttp2_session_want_write(session_) == 0 && wb_.rleft() == 0) {
     return -1;
@@ -1084,7 +1089,7 @@ const Config *Http2Handler::get_config() const {
 }
 
 void Http2Handler::remove_settings_timer() {
-  ev_timer_stop(sessions_->get_loop(), &settings_timerev_);
+  verto_del(verto_settings_timerev_);
 }
 
 void Http2Handler::terminate_session(uint32_t error_code) {
@@ -1792,46 +1797,19 @@ struct ClientInfo {
 
 struct Worker {
   std::unique_ptr<Sessions> sessions;
-  ev_async w;
   // protects q
   std::mutex m;
   std::deque<ClientInfo> q;
 };
 
-namespace {
-void worker_acceptcb(struct ev_loop *loop, ev_async *w, int revents) {
-  auto worker = static_cast<Worker *>(w->data);
-  auto &sessions = worker->sessions;
-
-  std::deque<ClientInfo> q;
-  {
-    std::lock_guard<std::mutex> lock(worker->m);
-    q.swap(worker->q);
-  }
-
-  for (const auto &c : q) {
-    sessions->accept_connection(c.fd);
-  }
-}
-} // namespace
-
 namespace {
 void run_worker(Worker *worker) {
-  auto loop = worker->sessions->get_loop();
+  auto verto_loop = worker->sessions->get_loop();
 
-  ev_run(loop, 0);
+  verto_run(verto_loop);
 }
 } // namespace
 
-namespace {
-int get_ev_loop_flags() {
-  if (ev_supported_backends() & ~ev_recommended_backends() & EVBACKEND_KQUEUE) {
-    return ev_recommended_backends() | EVBACKEND_KQUEUE;
-  }
-
-  return 0;
-}
-} // namespace
 
 class AcceptHandler {
 public:
@@ -1845,18 +1823,16 @@ public:
         std::cerr << "spawning thread #" << i << std::endl;
       }
       auto worker = std::make_unique<Worker>();
-      auto loop = ev_loop_new(get_ev_loop_flags());
-      worker->sessions = std::make_unique<Sessions>(sv, loop, config_,
+      auto verto_loop = verto_new(NULL, VERTO_EV_TYPE_NONE);
+      worker->sessions = std::make_unique<Sessions>(sv, verto_loop, config_,
                                                     sessions_->get_ssl_ctx());
-      ev_async_init(&worker->w, worker_acceptcb);
-      worker->w.data = worker.get();
-      ev_async_start(loop, &worker->w);
 
       auto t = std::thread(run_worker, worker.get());
       t.detach();
       workers_.push_back(std::move(worker));
     }
   }
+  
   void accept_connection(int fd) {
     if (config_->num_worker == 1) {
       sessions_->accept_connection(fd);
@@ -1875,7 +1851,18 @@ public:
       std::lock_guard<std::mutex> lock(worker->m);
       worker->q.push_back({fd});
     }
-    ev_async_send(worker->sessions->get_loop(), &worker->w);
+
+    auto &sessions = worker->sessions;
+
+    std::deque<ClientInfo> q;
+    {
+      std::lock_guard<std::mutex> lock(worker->m);
+      q.swap(worker->q);
+    } 
+
+    for (const auto &c : q) {
+      sessions->accept_connection(c.fd);
+    }
   }
 
 private:
@@ -1888,7 +1875,7 @@ private:
 };
 
 namespace {
-void acceptcb(struct ev_loop *loop, ev_io *w, int revents);
+void verto_acceptcb(verto_ctx *verto_loop, verto_ev *ev);
 } // namespace
 
 class ListenEventHandler {
@@ -1896,10 +1883,13 @@ public:
   ListenEventHandler(Sessions *sessions, int fd,
                      std::shared_ptr<AcceptHandler> acceptor)
       : acceptor_(std::move(acceptor)), sessions_(sessions), fd_(fd) {
-    ev_io_init(&w_, acceptcb, fd, EV_READ);
-    w_.data = this;
-    ev_io_start(sessions_->get_loop(), &w_);
+
+    // Add read event observers, add requests from clients
+    verto_ev_flag read_flag = (verto_ev_flag)(VERTO_EV_FLAG_PERSIST | VERTO_EV_FLAG_IO_READ);
+    verto_w_ = verto_add_io(sessions_->get_loop(), read_flag, verto_acceptcb, fd);
+    verto_set_private(verto_w_, this, NULL);
   }
+
   void accept_connection() {
     for (;;) {
 #ifdef HAVE_ACCEPT4
@@ -1918,15 +1908,15 @@ public:
   }
 
 private:
-  ev_io w_;
+  verto_ev *verto_w_;
   std::shared_ptr<AcceptHandler> acceptor_;
   Sessions *sessions_;
   int fd_;
 };
 
 namespace {
-void acceptcb(struct ev_loop *loop, ev_io *w, int revents) {
-  auto handler = static_cast<ListenEventHandler *>(w->data);
+void verto_acceptcb(verto_ctx *verto_loop, verto_ev *ev) {
+  auto handler = static_cast<ListenEventHandler *>(verto_get_private(ev));
   handler->accept_connection();
 }
 } // namespace
@@ -2017,7 +2007,7 @@ int verify_callback(int preverify_ok, X509_STORE_CTX *ctx) {
 } // namespace
 
 namespace {
-int start_listen(HttpServer *sv, struct ev_loop *loop, Sessions *sessions,
+int start_listen(HttpServer *sv, verto_ctx *verto_loop, Sessions *sessions,
                  const Config *config) {
   int r;
   bool ok = false;
@@ -2252,10 +2242,10 @@ int HttpServer::run() {
 #endif // OPENSSL_VERSION_NUMBER >= 0x10002000L
   }
 
-  auto loop = EV_DEFAULT;
+  auto verto_loop = verto_new(NULL, VERTO_EV_TYPE_NONE);
 
-  Sessions sessions(this, loop, config_, ssl_ctx);
-  if (start_listen(this, loop, &sessions, config_) != 0) {
+  Sessions sessions(this, verto_loop, config_, ssl_ctx);
+  if (start_listen(this, verto_loop, &sessions, config_) != 0) {
     std::cerr << "Could not listen" << std::endl;
     if (ssl_ctx) {
       SSL_CTX_free(ssl_ctx);
@@ -2263,8 +2253,8 @@ int HttpServer::run() {
     return -1;
   }
 
-  ev_run(loop, 0);
-  return 0;
+  verto_run(verto_loop);
+  return 0; 
 }
 
 const Config *HttpServer::get_config() const { return config_; }
@@ -2286,5 +2276,5 @@ const StatusPage *HttpServer::get_status_page(int status) const {
   }
   return nullptr;
 }
-
+ 
 } // namespace nghttp2
diff --git a/src/HttpServer.h b/src/HttpServer.h
index f825b83..c7dc7f1 100644
--- a/src/HttpServer.h
+++ b/src/HttpServer.h
@@ -1,4 +1,4 @@
-/*
+  /*
  * nghttp2 - HTTP/2 C Library
  *
  * Copyright (c) 2013 Tatsuhiro Tsujikawa
@@ -39,7 +39,7 @@
 
 #include <openssl/ssl.h>
 
-#include <ev.h>
+#include <verto-module.h>
 
 #include <nghttp2/nghttp2.h>
 
@@ -62,8 +62,10 @@ struct Config {
   std::string dh_param_file;
   std::string address;
   std::string mime_types_file;
-  ev_tstamp stream_read_timeout;
-  ev_tstamp stream_write_timeout;
+
+  double verto_stream_read_timeout;
+  double verto_stream_write_timeout;
+
   void *data_ptr;
   size_t padding;
   size_t num_worker;
@@ -142,8 +144,10 @@ struct Stream {
   RequestHeader header;
   Http2Handler *handler;
   FileEntry *file_ent;
-  ev_timer rtimer;
-  ev_timer wtimer;
+
+  verto_ev *verto_rtimer;
+  verto_ev *verto_wtimer;
+
   int64_t body_length;
   int64_t body_offset;
   // Total amount of bytes (sum of name and value length) used in
@@ -204,26 +208,32 @@ public:
   int read_tls();
   int write_tls();
 
-  struct ev_loop *get_loop() const;
+  verto_ctx *get_loop();
 
   using WriteBuf = Buffer<64_k>;
 
   WriteBuf *get_wb();
 
+  // An observer for writing events
+  verto_ev *verto_wev_;
+  // An observer for reading events
+  verto_ev *verto_rev_;
+  // An observer for timeout events
+  verto_ev *verto_settings_timerev_;
+  int fd_;
+
 private:
-  ev_io wev_;
-  ev_io rev_;
-  ev_timer settings_timerev_;
   std::map<int32_t, std::unique_ptr<Stream>> id2stream_;
   WriteBuf wb_;
+
   std::function<int(Http2Handler &)> read_, write_;
+ 
   int64_t session_id_;
   nghttp2_session *session_;
   Sessions *sessions_;
   SSL *ssl_;
   const uint8_t *data_pending_;
   size_t data_pendinglen_;
-  int fd_;
 };
 
 struct StatusPage {
diff --git a/src/h2load.cc b/src/h2load.cc
index 07b8357..40f3cf8 100644
--- a/src/h2load.cc
+++ b/src/h2load.cc
@@ -36,7 +36,7 @@
 #endif // HAVE_FCNTL_H
 #include <sys/mman.h>
 #include <netinet/udp.h>
-
+ 
 #include <cstdio>
 #include <cassert>
 #include <cstdlib>
@@ -203,8 +203,8 @@ void sampling_init(Sampling &smp, size_t max_samples) {
 } // namespace
 
 namespace {
-void writecb(struct ev_loop *loop, ev_io *w, int revents) {
-  auto client = static_cast<Client *>(w->data);
+void verto_writecb(verto_ctx *verto_loop, verto_ev *ev) {
+  auto client = static_cast<Client *>(verto_get_private(ev));
   client->restart_timeout();
   auto rv = client->do_write();
   if (rv == Client::ERR_CONNECT_FAIL) {
@@ -229,8 +229,16 @@ void writecb(struct ev_loop *loop, ev_io *w, int revents) {
 } // namespace
 
 namespace {
-void readcb(struct ev_loop *loop, ev_io *w, int revents) {
-  auto client = static_cast<Client *>(w->data);
+void verto_readcb(verto_ctx *verto_loop, verto_ev *ev) {
+  auto client = static_cast<Client *>(verto_get_private(ev));
+
+  // In order to wait for the callback for the read event
+  // the write event observer was removed from the event loop in the previous step
+  // So now we need to add the read event observer into the event loop
+  verto_ev_flag write_flag = (verto_ev_flag)(VERTO_EV_FLAG_PERSIST | VERTO_EV_FLAG_IO_WRITE);
+  client->verto_wev = verto_add_io(client->worker->verto_loop, write_flag, verto_writecb, client->fd);
+  verto_set_private(client->verto_wev, client, NULL);
+
   client->restart_timeout();
   if (client->do_read() != 0) {
     if (client->try_again_or_fail() == 0) {
@@ -240,14 +248,13 @@ void readcb(struct ev_loop *loop, ev_io *w, int revents) {
     delete client;
     return;
   }
-  client->signal_write();
-}
+} 
 } // namespace
 
 namespace {
 // Called every rate_period when rate mode is being used
-void rate_period_timeout_w_cb(struct ev_loop *loop, ev_timer *w, int revents) {
-  auto worker = static_cast<Worker *>(w->data);
+void verto_rate_period_timeout_w_cb(verto_ctx *verto_loop, verto_ev *ev) {
+  auto worker = static_cast<Worker *>(verto_get_private(ev));
   auto nclients_per_second = worker->rate;
   auto conns_remaining = worker->nclients - worker->nconns_made;
   auto nclients = std::min(nclients_per_second, conns_remaining);
@@ -258,6 +265,8 @@ void rate_period_timeout_w_cb(struct ev_loop *loop, ev_timer *w, int revents) {
       ++req_todo;
       --worker->nreqs_rem;
     }
+
+    verto_loop = verto_new(NULL, VERTO_EV_TYPE_NONE);
     auto client =
         std::make_unique<Client>(worker->next_client_id++, worker, req_todo);
 
@@ -274,10 +283,12 @@ void rate_period_timeout_w_cb(struct ev_loop *loop, ev_timer *w, int revents) {
       }
     }
     worker->report_rate_progress();
+    verto_run(verto_loop);
+    verto_free(verto_loop);
   }
   if (!worker->config->is_timing_based_mode()) {
     if (worker->nconns_made >= worker->nclients) {
-      ev_timer_stop(worker->loop, w);
+      verto_del(ev);
     }
   } else {
     // To check whether all created clients are pushed correctly
@@ -288,8 +299,8 @@ void rate_period_timeout_w_cb(struct ev_loop *loop, ev_timer *w, int revents) {
 
 namespace {
 // Called when the duration for infinite number of requests are over
-void duration_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents) {
-  auto worker = static_cast<Worker *>(w->data);
+void verto_duration_timeout_cb(verto_ctx *verto_loop, verto_ev *ev) {
+  auto worker = static_cast<Worker *>(verto_get_private(ev));
 
   worker->current_phase = Phase::DURATION_OVER;
 
@@ -302,8 +313,8 @@ void duration_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents) {
 
 namespace {
 // Called when the warmup duration for infinite number of requests are over
-void warmup_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents) {
-  auto worker = static_cast<Worker *>(w->data);
+void verto_warmup_timeout_cb(verto_ctx *verto_loop, verto_ev *ev) {
+  auto worker = static_cast<Worker *>(verto_get_private(ev));
 
   std::cout << "Warm-up phase is over for thread #" << worker->id << "."
             << std::endl;
@@ -328,19 +339,20 @@ void warmup_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents) {
 
   worker->current_phase = Phase::MAIN_DURATION;
 
-  ev_timer_start(worker->loop, &worker->duration_watcher);
+  worker->verto_duration_watcher = verto_add_timeout(worker->verto_loop, VERTO_EV_FLAG_NONE, verto_duration_timeout_cb, worker->config->duration);
+  verto_set_private(worker->verto_duration_watcher, worker, NULL);
 }
 } // namespace
 
 namespace {
-void rps_cb(struct ev_loop *loop, ev_timer *w, int revents) {
-  auto client = static_cast<Client *>(w->data);
+void verto_rps_cb(verto_ctx *verto_loop, verto_ev *ev) {
+  auto client = static_cast<Client *>(verto_get_private(ev));
   auto &session = client->session;
 
   assert(!config.timing_script);
 
   if (client->req_left == 0) {
-    ev_timer_stop(loop, w);
+    verto_del(ev);
     return;
   }
 
@@ -374,8 +386,6 @@ void rps_cb(struct ev_loop *loop, ev_timer *w, int revents) {
       break;
     }
   }
-
-  client->signal_write();
 }
 } // namespace
 
@@ -383,11 +393,11 @@ namespace {
 // Called when an a connection has been inactive for a set period of time
 // or a fixed amount of time after all requests have been made on a
 // connection
-void conn_timeout_cb(EV_P_ ev_timer *w, int revents) {
-  auto client = static_cast<Client *>(w->data);
+void verto_conn_timeout_cb(verto_ctx *verto_loop, verto_ev *ev) {
+  auto client = static_cast<Client *>(verto_get_private(ev));
 
-  ev_timer_stop(client->worker->loop, &client->conn_inactivity_watcher);
-  ev_timer_stop(client->worker->loop, &client->conn_active_watcher);
+  verto_del(client->verto_conn_inactivity_watcher);
+  verto_del(client->verto_conn_active_watcher);
 
   if (util::check_socket_connected(client->fd)) {
     client->timeout();
@@ -396,10 +406,10 @@ void conn_timeout_cb(EV_P_ ev_timer *w, int revents) {
 } // namespace
 
 namespace {
-bool check_stop_client_request_timeout(Client *client, ev_timer *w) {
+bool check_stop_client_request_timeout(Client *client, verto_ev *ev) {
   if (client->req_left == 0) {
     // no more requests to make, stop timer
-    ev_timer_stop(client->worker->loop, w);
+    verto_del(ev);
     return true;
   }
 
@@ -408,22 +418,21 @@ bool check_stop_client_request_timeout(Client *client, ev_timer *w) {
 } // namespace
 
 namespace {
-void client_request_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents) {
-  auto client = static_cast<Client *>(w->data);
+void verto_client_request_timeout_cb(verto_ctx *verto_loop, verto_ev *ev) {
+  auto client = static_cast<Client *>(verto_get_private(ev));
 
   if (client->streams.size() >= (size_t)config.max_concurrent_streams) {
-    ev_timer_stop(client->worker->loop, w);
+    verto_del(ev);
     return;
   }
 
   if (client->submit_request() != 0) {
-    ev_timer_stop(client->worker->loop, w);
+    verto_del(ev);
     client->process_request_failure();
     return;
   }
-  client->signal_write();
 
-  if (check_stop_client_request_timeout(client, w)) {
+  if (check_stop_client_request_timeout(client, ev)) {
     return;
   }
 
@@ -432,12 +441,12 @@ void client_request_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents) {
 
   while (duration < std::chrono::duration<double>(1e-9)) {
     if (client->submit_request() != 0) {
-      ev_timer_stop(client->worker->loop, w);
+      verto_del(ev);
       client->process_request_failure();
       return;
     }
     client->signal_write();
-    if (check_stop_client_request_timeout(client, w)) {
+    if (check_stop_client_request_timeout(client, ev)) {
       return;
     }
 
@@ -445,9 +454,9 @@ void client_request_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents) {
         config.timings[client->reqidx] - config.timings[client->reqidx - 1];
   }
 
-  client->request_timeout_watcher.repeat = util::ev_tstamp_from(duration);
-  ev_timer_again(client->worker->loop, &client->request_timeout_watcher);
-}
+  verto_del(ev);
+  client->verto_request_timeout_watcher = verto_add_timeout(client->worker->verto_loop, VERTO_EV_FLAG_PERSIST, verto_client_request_timeout_cb, util::ev_tstamp_from(duration) * 1000);
+  verto_set_private(client->verto_request_timeout_watcher, client, NULL);}
 } // namespace
 
 Client::Client(uint32_t id, Worker *worker, size_t req_todo)
@@ -479,30 +488,8 @@ Client::Client(uint32_t id, Worker *worker, size_t req_todo)
     // Just a positive number is fine, we chose the first positive number
     req_left = 1;
   }
-  ev_io_init(&wev, writecb, 0, EV_WRITE);
-  ev_io_init(&rev, readcb, 0, EV_READ);
-
-  wev.data = this;
-  rev.data = this;
-
-  ev_timer_init(&conn_inactivity_watcher, conn_timeout_cb, 0.,
-                worker->config->conn_inactivity_timeout);
-  conn_inactivity_watcher.data = this;
-
-  ev_timer_init(&conn_active_watcher, conn_timeout_cb,
-                worker->config->conn_active_timeout, 0.);
-  conn_active_watcher.data = this;
-
-  ev_timer_init(&request_timeout_watcher, client_request_timeout_cb, 0., 0.);
-  request_timeout_watcher.data = this;
-
-  ev_timer_init(&rps_watcher, rps_cb, 0., 0.);
-  rps_watcher.data = this;
 
 #ifdef ENABLE_HTTP3
-  ev_timer_init(&quic.pkt_timer, quic_pkt_timeout_cb, 0., 0.);
-  quic.pkt_timer.data = this;
-
   if (config.is_quic()) {
     quic.tx.data = std::make_unique<uint8_t[]>(64_k);
   }
@@ -616,11 +603,13 @@ int Client::connect() {
     worker->current_phase = Phase::WARM_UP;
     std::cout << "Warm-up started for thread #" << worker->id << "."
               << std::endl;
-    ev_timer_start(worker->loop, &worker->warmup_watcher);
+    worker->verto_warmup_watcher = verto_add_timeout(worker->verto_loop, VERTO_EV_FLAG_NONE, verto_warmup_timeout_cb, worker->config->warm_up_time);
+    verto_set_private(worker->verto_warmup_watcher, worker, NULL);
   }
 
   if (worker->config->conn_inactivity_timeout > 0.) {
-    ev_timer_again(worker->loop, &conn_inactivity_watcher);
+    verto_conn_inactivity_watcher = verto_add_timeout(worker->verto_loop, VERTO_EV_FLAG_PERSIST, verto_conn_timeout_cb, worker->config->conn_inactivity_timeout * 1000);
+    verto_set_private(verto_conn_inactivity_watcher, this, NULL);
   }
 
   if (current_addr) {
@@ -648,15 +637,17 @@ int Client::connect() {
     current_addr = addr;
   }
 
-  ev_io_set(&rev, fd, EV_READ);
-  ev_io_set(&wev, fd, EV_WRITE);
+  // Add read event observers and write event observers to the event loop
+  verto_ev_flag read_flag = (verto_ev_flag)(VERTO_EV_FLAG_PERSIST | VERTO_EV_FLAG_IO_READ);
+  verto_rev = verto_add_io(worker->verto_loop, read_flag, verto_readcb, fd);
+  verto_set_private(verto_rev, this, NULL);
 
-  ev_io_start(worker->loop, &wev);
+  verto_ev_flag write_flag = (verto_ev_flag)(VERTO_EV_FLAG_PERSIST | VERTO_EV_FLAG_IO_WRITE);
+  verto_wev = verto_add_io(worker->verto_loop, write_flag, verto_writecb, fd);
+  verto_set_private(verto_wev, this, NULL);
 
   if (config.is_quic()) {
 #ifdef ENABLE_HTTP3
-    ev_io_start(worker->loop, &rev);
-
     readfn = &Client::read_quic;
     writefn = &Client::write_quic;
 #endif // ENABLE_HTTP3
@@ -675,7 +666,8 @@ void Client::timeout() {
 
 void Client::restart_timeout() {
   if (worker->config->conn_inactivity_timeout > 0.) {
-    ev_timer_again(worker->loop, &conn_inactivity_watcher);
+    verto_conn_inactivity_watcher = verto_add_timeout(worker->verto_loop, VERTO_EV_FLAG_PERSIST, verto_conn_timeout_cb, worker->config->conn_inactivity_timeout * 1000);
+    verto_set_private(verto_conn_inactivity_watcher, this, NULL);
   }
 }
 
@@ -723,20 +715,10 @@ void Client::disconnect() {
     quic_close_connection();
   }
 #endif // ENABLE_HTTP3
-
-#ifdef ENABLE_HTTP3
-  ev_timer_stop(worker->loop, &quic.pkt_timer);
-#endif // ENABLE_HTTP3
-  ev_timer_stop(worker->loop, &conn_inactivity_watcher);
-  ev_timer_stop(worker->loop, &conn_active_watcher);
-  ev_timer_stop(worker->loop, &rps_watcher);
-  ev_timer_stop(worker->loop, &request_timeout_watcher);
   streams.clear();
   session.reset();
   wb.reset();
   state = CLIENT_IDLE;
-  ev_io_stop(worker->loop, &wev);
-  ev_io_stop(worker->loop, &rev);
   if (ssl) {
     if (config.is_quic()) {
       SSL_free(ssl);
@@ -758,6 +740,8 @@ void Client::disconnect() {
   }
 
   final = false;
+  // Exit the event loop
+  verto_break(worker->verto_loop);
 }
 
 int Client::submit_request() {
@@ -778,8 +762,8 @@ int Client::submit_request() {
   // if an active timeout is set and this is the last request to be submitted
   // on this connection, start the active timeout.
   if (worker->config->conn_active_timeout > 0. && req_left == 0) {
-    ev_timer_start(worker->loop, &conn_active_watcher);
-  }
+    verto_conn_active_watcher = verto_add_timeout(worker->verto_loop, VERTO_EV_FLAG_NONE, verto_conn_timeout_cb, worker->config->conn_active_timeout);
+    verto_set_private(verto_conn_active_watcher, this, NULL);  }
 
   return 0;
 }
@@ -913,8 +897,6 @@ void Client::terminate_session() {
   if (session) {
     session->terminate();
   }
-  // http1 session needs writecb to tear down session.
-  signal_write();
 }
 
 void Client::on_request(int32_t stream_id) { streams[stream_id] = Stream(); }
@@ -1063,11 +1045,7 @@ void Client::on_stream_close(int32_t stream_id, bool success, bool final) {
   }
 
   if (!final && req_left > 0) {
-    if (config.timing_script) {
-      if (!ev_is_active(&request_timeout_watcher)) {
-        ev_feed_event(worker->loop, &request_timeout_watcher, EV_TIMER);
-      }
-    } else if (!config.rps_enabled()) {
+    if (!config.rps_enabled()) {
       if (submit_request() != 0) {
         process_request_failure();
       }
@@ -1185,8 +1163,8 @@ int Client::connection_made() {
   record_connect_time();
 
   if (config.rps_enabled()) {
-    rps_watcher.repeat = std::max(0.01, 1. / config.rps);
-    ev_timer_again(worker->loop, &rps_watcher);
+    verto_rps_watcher = verto_add_timeout(worker->verto_loop, VERTO_EV_FLAG_PERSIST, verto_rps_cb, std::max(0.01, 1. / config.rps) * 1000);
+    verto_set_private(verto_rps_watcher, this, NULL);
     rps_duration_started = std::chrono::steady_clock::now();
   }
 
@@ -1229,11 +1207,10 @@ int Client::connection_made() {
     if (duration >= std::chrono::duration<double>(1e-9)) {
       // double check since we may have break due to reqidx wraps
       // around back to 0
-      request_timeout_watcher.repeat = util::ev_tstamp_from(duration);
-      ev_timer_again(worker->loop, &request_timeout_watcher);
+      verto_request_timeout_watcher = verto_add_timeout(worker->verto_loop, VERTO_EV_FLAG_PERSIST, verto_client_request_timeout_cb, util::ev_tstamp_from(duration) * 1000);
+      verto_set_private(verto_request_timeout_watcher, this, NULL);
     }
   }
-  signal_write();
 
   return 0;
 }
@@ -1246,7 +1223,6 @@ int Client::on_read(const uint8_t *data, size_t len) {
   if (worker->current_phase == Phase::MAIN_DURATION) {
     worker->stats.bytes_total += len;
   }
-  signal_write();
   return 0;
 }
 
@@ -1307,7 +1283,6 @@ int Client::write_clear() {
 
     if (nwrite == -1) {
       if (errno == EAGAIN || errno == EWOULDBLOCK) {
-        ev_io_start(worker->loop, &wev);
         return 0;
       }
       return -1;
@@ -1316,8 +1291,6 @@ int Client::write_clear() {
     wb.drain(nwrite);
   }
 
-  ev_io_stop(worker->loop, &wev);
-
   return 0;
 }
 
@@ -1325,8 +1298,6 @@ int Client::connected() {
   if (!util::check_socket_connected(fd)) {
     return ERR_CONNECT_FAIL;
   }
-  ev_io_start(worker->loop, &rev);
-  ev_io_stop(worker->loop, &wev);
 
   if (ssl) {
     SSL_set_fd(ssl, fd);
@@ -1356,18 +1327,17 @@ int Client::tls_handshake() {
     auto err = SSL_get_error(ssl, rv);
     switch (err) {
     case SSL_ERROR_WANT_READ:
-      ev_io_stop(worker->loop, &wev);
+      // Remove the write observer  
+      // add it to the event loop inside the read event callback
+      verto_del(verto_wev);      
       return 0;
     case SSL_ERROR_WANT_WRITE:
-      ev_io_start(worker->loop, &wev);
       return 0;
     default:
       return -1;
     }
   }
 
-  ev_io_stop(worker->loop, &wev);
-
   readfn = &Client::read_tls;
   writefn = &Client::write_tls;
 
@@ -1418,6 +1388,8 @@ int Client::write_tls() {
     auto iovcnt = wb.riovec(&iov, 1);
 
     if (iovcnt == 0) {
+      // iovcnt == 0 indicates that the write event is no longer needed
+      verto_del(verto_wev);
       break;
     }
 
@@ -1430,7 +1402,6 @@ int Client::write_tls() {
         // renegotiation started
         return -1;
       case SSL_ERROR_WANT_WRITE:
-        ev_io_start(worker->loop, &wev);
         return 0;
       default:
         return -1;
@@ -1440,8 +1411,6 @@ int Client::write_tls() {
     wb.drain(rv);
   }
 
-  ev_io_stop(worker->loop, &wev);
-
   return 0;
 }
 
@@ -1484,8 +1453,6 @@ int Client::write_udp(const sockaddr *addr, socklen_t addrlen,
     ++worker->stats.udp_dgram_sent;
   }
 
-  ev_io_stop(worker->loop, &wev);
-
   return 0;
 }
 #endif // ENABLE_HTTP3
@@ -1533,25 +1500,20 @@ void Client::record_client_end_time() {
   cstat.client_end_time = std::chrono::steady_clock::now();
 }
 
-void Client::signal_write() { ev_io_start(worker->loop, &wev); }
-
-void Client::try_new_connection() { new_connection_requested = true; }
-
-namespace {
-int get_ev_loop_flags() {
-  if (ev_supported_backends() & ~ev_recommended_backends() & EVBACKEND_KQUEUE) {
-    return ev_recommended_backends() | EVBACKEND_KQUEUE;
-  }
+void Client::signal_write() {
+  // This function has no effect on libverto-based projects,
+  // but it is used in some files and needs to be retained 
+}
 
-  return 0;
+void Client::try_new_connection() { 
+  new_connection_requested = true; 
 }
-} // namespace
+
 
 Worker::Worker(uint32_t id, SSL_CTX *ssl_ctx, size_t req_todo, size_t nclients,
                size_t rate, size_t max_samples, Config *config)
     : randgen(util::make_mt19937()),
       stats(req_todo, nclients),
-      loop(ev_loop_new(get_ev_loop_flags())),
       ssl_ctx(ssl_ctx),
       config(config),
       id(id),
@@ -1570,12 +1532,6 @@ Worker::Worker(uint32_t id, SSL_CTX *ssl_ctx, size_t req_todo, size_t nclients,
     progress_interval = std::max(static_cast<size_t>(1), nclients / 10);
   }
 
-  // Below timeout is not needed in case of timing-based benchmarking
-  // create timer that will go off every rate_period
-  ev_timer_init(&timeout_watcher, rate_period_timeout_w_cb, 0.,
-                config->rate_period);
-  timeout_watcher.data = this;
-
   if (config->is_timing_based_mode()) {
     stats.req_stats.reserve(std::max(req_todo, max_samples));
     stats.client_stats.reserve(std::max(nclients, max_samples));
@@ -1587,12 +1543,6 @@ Worker::Worker(uint32_t id, SSL_CTX *ssl_ctx, size_t req_todo, size_t nclients,
   sampling_init(request_times_smp, max_samples);
   sampling_init(client_smp, max_samples);
 
-  ev_timer_init(&duration_watcher, duration_timeout_cb, config->duration, 0.);
-  duration_watcher.data = this;
-
-  ev_timer_init(&warmup_watcher, warmup_timeout_cb, config->warm_up_time, 0.);
-  warmup_watcher.data = this;
-
   if (config->is_timing_based_mode()) {
     current_phase = Phase::INITIAL_IDLE;
   } else {
@@ -1601,10 +1551,8 @@ Worker::Worker(uint32_t id, SSL_CTX *ssl_ctx, size_t req_todo, size_t nclients,
 }
 
 Worker::~Worker() {
-  ev_timer_stop(loop, &timeout_watcher);
-  ev_timer_stop(loop, &duration_watcher);
-  ev_timer_stop(loop, &warmup_watcher);
-  ev_loop_destroy(loop);
+  // Clear all event loops
+  verto_cleanup();
 }
 
 void Worker::stop_all_clients() {
@@ -1628,6 +1576,7 @@ void Worker::free_client(Client *deleted_client) {
 }
 
 void Worker::run() {
+
   if (!config->is_rate_mode() && !config->is_timing_based_mode()) {
     for (size_t i = 0; i < nclients; ++i) {
       auto req_todo = nreqs_per_client;
@@ -1636,6 +1585,7 @@ void Worker::run() {
         --nreqs_rem;
       }
 
+      verto_loop = verto_new(NULL, VERTO_EV_TYPE_NONE);
       auto client = std::make_unique<Client>(next_client_id++, this, req_todo);
       if (client->connect() != 0) {
         std::cerr << "client could not connect to host" << std::endl;
@@ -1643,17 +1593,16 @@ void Worker::run() {
       } else {
         client.release();
       }
-    }
-  } else if (config->is_rate_mode()) {
-    ev_timer_again(loop, &timeout_watcher);
+      verto_run(verto_loop);
+      verto_free(verto_loop);
 
-    // call callback so that we don't waste the first rate_period
-    rate_period_timeout_w_cb(loop, &timeout_watcher, 0);
+    }
   } else {
     // call the callback to start for one single time
-    rate_period_timeout_w_cb(loop, &timeout_watcher, 0);
+    verto_timeout_watcher = verto_add_timeout(verto_new(NULL, VERTO_EV_TYPE_NONE), VERTO_EV_FLAG_NONE, verto_rate_period_timeout_w_cb, 0);
+    verto_set_private(verto_timeout_watcher, this, NULL);
+    verto_rate_period_timeout_w_cb(verto_new(NULL, VERTO_EV_TYPE_NONE), verto_timeout_watcher);
   }
-  ev_run(loop, 0);
 }
 
 namespace {
@@ -3319,7 +3268,10 @@ time for request: )"
 
   return 0;
 }
-
+ 
 } // namespace h2load
 
-int main(int argc, char **argv) { return h2load::main(argc, argv); }
+int main(int argc, char **argv) { 
+  return h2load::main(argc, argv); 
+}
+
diff --git a/src/h2load.h b/src/h2load.h
index d848fdf..84b2789 100644
--- a/src/h2load.h
+++ b/src/h2load.h
@@ -35,7 +35,7 @@
 #  include <netdb.h>
 #endif // HAVE_NETDB_H
 #include <sys/un.h>
-
+ 
 #include <vector>
 #include <string>
 #include <unordered_map>
@@ -50,7 +50,7 @@
 #  include <ngtcp2/ngtcp2_crypto.h>
 #endif // ENABLE_HTTP3
 
-#include <ev.h>
+#include <verto-module.h>
 
 #include <openssl/ssl.h>
 
@@ -98,15 +98,15 @@ struct Config {
   size_t max_frame_size;
   // rate at which connections should be made
   size_t rate;
-  ev_tstamp rate_period;
+  double rate_period;
   // amount of time for main measurements in timing-based test
-  ev_tstamp duration;
+  double duration;
   // amount of time to wait before starting measurements in timing-based test
-  ev_tstamp warm_up_time;
+  double warm_up_time;
   // amount of time to wait for activity on a given connection
-  ev_tstamp conn_active_timeout;
+  double conn_active_timeout;
   // amount of time to wait after the last request is made on a connection
-  ev_tstamp conn_inactivity_timeout;
+  double conn_inactivity_timeout;
   enum { PROTO_HTTP2, PROTO_HTTP1_1 } no_tls_proto;
   uint32_t header_table_size;
   uint32_t encoder_header_table_size;
@@ -276,7 +276,7 @@ struct Worker {
   Stats stats;
   Sampling request_times_smp;
   Sampling client_smp;
-  struct ev_loop *loop;
+  verto_ctx *verto_loop;
   SSL_CTX *ssl_ctx;
   Config *config;
   size_t progress_interval;
@@ -293,7 +293,7 @@ struct Worker {
   size_t rate;
   // maximum number of samples in this worker thread
   size_t max_samples;
-  ev_timer timeout_watcher;
+  verto_ev *verto_timeout_watcher;
   // The next client ID this worker assigns
   uint32_t next_client_id;
   // Keeps track of the current phase (for timing-based experiment) for the
@@ -303,8 +303,8 @@ struct Worker {
   std::vector<Client *> clients;
   // This is only active when there is not a bounded number of requests
   // specified
-  ev_timer duration_watcher;
-  ev_timer warmup_watcher;
+  verto_ev *verto_duration_watcher;
+  verto_ev *verto_warmup_watcher;
 
   Worker(uint32_t id, SSL_CTX *ssl_ctx, size_t nreq_todo, size_t nclients,
          size_t rate, size_t max_samples, Config *config);
@@ -332,15 +332,15 @@ struct Client {
   std::unordered_map<int32_t, Stream> streams;
   ClientStat cstat;
   std::unique_ptr<Session> session;
-  ev_io wev;
-  ev_io rev;
+  verto_ev *verto_wev;
+  verto_ev *verto_rev;
   std::function<int(Client &)> readfn, writefn;
   Worker *worker;
   SSL *ssl;
 #ifdef ENABLE_HTTP3
   struct {
     ngtcp2_crypto_conn_ref conn_ref;
-    ev_timer pkt_timer;
+    verto_ev *verto_pkt_timer;
     ngtcp2_conn *conn;
     ngtcp2_ccerr last_error;
     bool close_requested;
@@ -360,7 +360,7 @@ struct Client {
     } tx;
   } quic;
 #endif // ENABLE_HTTP3
-  ev_timer request_timeout_watcher;
+  verto_ev *verto_request_timeout_watcher;
   addrinfo *next_addr;
   // Address for the current address.  When try_new_connection() is
   // used and current_addr is not nullptr, it is used instead of
@@ -384,8 +384,8 @@ struct Client {
   uint32_t id;
   int fd;
   Address local_addr;
-  ev_timer conn_active_watcher;
-  ev_timer conn_inactivity_watcher;
+  verto_ev *verto_conn_active_watcher;
+  verto_ev *verto_conn_inactivity_watcher;
   std::string selected_proto;
   bool new_connection_requested;
   // true if the current connection will be closed, and no more new
@@ -393,7 +393,7 @@ struct Client {
   bool final;
   // rps_watcher is a timer to invoke callback periodically to
   // generate a new request.
-  ev_timer rps_watcher;
+  verto_ev *verto_rps_watcher;
   // The timestamp that starts the period which contributes to the
   // next request generation.
   std::chrono::steady_clock::time_point rps_duration_started;
@@ -508,3 +508,4 @@ struct Client {
 } // namespace h2load
 
 #endif // H2LOAD_H
+
diff --git a/src/h2load_http2_session.cc b/src/h2load_http2_session.cc
index 9cafa0e..73b9be6 100644
--- a/src/h2load_http2_session.cc
+++ b/src/h2load_http2_session.cc
@@ -37,7 +37,8 @@ using namespace nghttp2;
 namespace h2load {
 
 Http2Session::Http2Session(Client *client)
-    : client_(client), session_(nullptr) {}
+    : client_(client), session_(nullptr) { 
+}
 
 Http2Session::~Http2Session() { nghttp2_session_del(session_); }
 
@@ -49,7 +50,7 @@ int on_header_callback(nghttp2_session *session, const nghttp2_frame *frame,
   auto client = static_cast<Client *>(user_data);
   if (frame->hd.type != NGHTTP2_HEADERS ||
       frame->headers.cat != NGHTTP2_HCAT_RESPONSE) {
-    return 0;
+    return 0; 
   }
   client->on_header(frame->hd.stream_id, name, namelen, value, valuelen);
   client->worker->stats.bytes_head_decomp += namelen + valuelen;
@@ -202,6 +203,7 @@ void Http2Session::on_connect() {
   nghttp2_option *opt;
 
   rv = nghttp2_option_new(&opt);
+
   assert(rv == 0);
 
   auto config = client_->worker->config;
@@ -241,7 +243,6 @@ void Http2Session::on_connect() {
   nghttp2_session_set_local_window_size(session_, NGHTTP2_FLAG_NONE, 0,
                                         connection_window);
 
-  client_->signal_write();
 }
 
 int Http2Session::submit_request() {
@@ -283,8 +284,6 @@ int Http2Session::on_read(const uint8_t *data, size_t len) {
     return -1;
   }
 
-  client_->signal_write();
-
   return 0;
 }
 
diff --git a/src/h2load_quic.cc b/src/h2load_quic.cc
index 65fbc10..ef9ceb5 100644
--- a/src/h2load_quic.cc
+++ b/src/h2load_quic.cc
@@ -1,4 +1,4 @@
-/*
+ /*
  * nghttp2 - HTTP/2 C Library
  *
  * Copyright (c) 2019 nghttp2 contributors
@@ -504,8 +504,8 @@ int Client::quic_write_client_handshake(ngtcp2_encryption_level level,
   return 0;
 }
 
-void quic_pkt_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents) {
-  auto c = static_cast<Client *>(w->data);
+void verto_quic_pkt_timeout_cb(verto_ctx *verto_loop, verto_ev *ev) {
+  auto c = static_cast<Client *>(verto_get_private(ev));
 
   if (c->quic_pkt_timeout() != 0) {
     c->fail();
@@ -531,10 +531,10 @@ int Client::quic_pkt_timeout() {
 void Client::quic_restart_pkt_timer() {
   auto expiry = ngtcp2_conn_get_expiry(quic.conn);
   auto now = quic_timestamp();
-  auto t = expiry > now ? static_cast<ev_tstamp>(expiry - now) / NGTCP2_SECONDS
+  auto t = expiry > now ? static_cast<double>(expiry - now) / NGTCP2_SECONDS
                         : 1e-9;
-  quic.pkt_timer.repeat = t;
-  ev_timer_again(worker->loop, &quic.pkt_timer);
+  // quic.pkt_timer.repeat = t;
+  // ev_timer_again(worker->loop, &quic.pkt_timer);
 }
 
 int Client::read_quic() {
@@ -628,7 +628,7 @@ int Client::read_quic() {
 int Client::write_quic() {
   int rv;
 
-  ev_io_stop(worker->loop, &wev);
+  //ev_io_stop(worker->loop, &wev);
 
   if (quic.close_requested) {
     return -1;
@@ -722,7 +722,6 @@ int Client::write_quic() {
                        datalen, gso_size);
         if (rv == 1) {
           on_send_blocked(ps.path.remote, data, datalen, gso_size);
-          signal_write();
           return 0;
         }
       }
@@ -740,12 +739,10 @@ int Client::write_quic() {
                      0);
       if (rv == 1) {
         on_send_blocked(ps.path.remote, data, datalen, 0);
-        signal_write();
         return 0;
       }
 
       if (++pktcnt == max_pktcnt) {
-        signal_write();
         return 0;
       }
 
@@ -778,7 +775,6 @@ int Client::write_quic() {
         }
       }
 
-      signal_write();
       return 0;
     }
 
@@ -791,7 +787,6 @@ int Client::write_quic() {
       if (rv == 1) {
         on_send_blocked(ps.path.remote, data, datalen, gso_size);
       }
-      signal_write();
       return 0;
     }
 #endif // UDP_SEGMENT
@@ -828,8 +823,6 @@ int Client::send_blocked_packet() {
     rv = write_udp(&p.remote_addr.su.sa, p.remote_addr.len, p.data, p.datalen,
                    p.gso_size);
     if (rv == 1) {
-      signal_write();
-
       return 0;
     }
   }
@@ -842,3 +835,4 @@ int Client::send_blocked_packet() {
 }
 
 } // namespace h2load
+
diff --git a/src/h2load_quic.h b/src/h2load_quic.h
index 225f00f..f16de12 100644
--- a/src/h2load_quic.h
+++ b/src/h2load_quic.h
@@ -1,4 +1,4 @@
-/*
+ /*
  * nghttp2 - HTTP/2 C Library
  *
  * Copyright (c) 2019 nghttp2 contributors
@@ -27,12 +27,10 @@
 
 #include "nghttp2_config.h"
 
-#include <ev.h>
-
 #include "h2load.h"
 
 namespace h2load {
-void quic_pkt_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents);
+void verto_quic_pkt_timeout_cb(verto_ctx *verto_loop, verto_ev *ev);
 } // namespace h2load
 
 #endif // H2LOAD_QUIC_H
diff --git a/src/nghttp.cc b/src/nghttp.cc
index d4576f3..0bb13bf 100644
--- a/src/nghttp.cc
+++ b/src/nghttp.cc
@@ -1,4 +1,4 @@
-/*
+ /*
  * nghttp2 - HTTP/2 C Library
  *
  * Copyright (c) 2013 Tatsuhiro Tsujikawa
@@ -24,6 +24,7 @@
  */
 #include "nghttp.h"
 
+#include <signal.h>
 #include <sys/stat.h>
 #ifdef HAVE_UNISTD_H
 #  include <unistd.h>
@@ -106,10 +107,10 @@ Config::Config()
       max_concurrent_streams(100),
       peer_max_concurrent_streams(100),
       multiply(1),
-      timeout(0.),
       window_bits(-1),
       connection_window_bits(-1),
       verbose(0),
+      timeout(0.),
       port_override(0),
       null_out(false),
       remote_name(false),
@@ -365,9 +366,10 @@ void Request::record_response_end_time() {
 }
 
 namespace {
-void continue_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents) {
-  auto client = static_cast<HttpClient *>(ev_userdata(loop));
-  auto req = static_cast<Request *>(w->data);
+void verto_continue_timeout_cb(verto_ctx *verto_loop, verto_ev *ev) {
+  auto req = static_cast<Request *>(verto_get_private(ev));
+  auto client = static_cast<HttpClient *>(req->client);
+
   int error;
 
   error = nghttp2_submit_data(client->session, NGHTTP2_FLAG_END_STREAM,
@@ -379,27 +381,31 @@ void continue_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents) {
     nghttp2_submit_rst_stream(client->session, NGHTTP2_FLAG_NONE,
                               req->stream_id, NGHTTP2_INTERNAL_ERROR);
   }
-
-  client->signal_write();
 }
 } // namespace
 
-ContinueTimer::ContinueTimer(struct ev_loop *loop, Request *req) : loop(loop) {
-  ev_timer_init(&timer, continue_timeout_cb, 1., 0.);
-  timer.data = req;
+ContinueTimer::ContinueTimer(verto_ctx *verto_loop, Request *req, HttpClient *client): 
+    verto_loop(verto_loop),
+    req(req) {
+    req->client = client;
 }
 
 ContinueTimer::~ContinueTimer() { stop(); }
 
-void ContinueTimer::start() { ev_timer_start(loop, &timer); }
+void ContinueTimer::start() { 
+  // Add a timeout event observer to the verto_loop
+  verto_timer = verto_add_timeout(verto_loop, VERTO_EV_FLAG_NONE, verto_continue_timeout_cb, 1000);
+  verto_set_private(verto_timer, req, NULL);
+}
 
-void ContinueTimer::stop() { ev_timer_stop(loop, &timer); }
+void ContinueTimer::stop() { 
+  // Remove the timeout event observer from the verto_loop
+  verto_del(verto_timer);
+}
 
 void ContinueTimer::dispatch_continue() {
-  // Only dispatch the timeout callback if it hasn't already been called.
-  if (ev_is_active(&timer)) {
-    ev_feed_event(loop, &timer, 0);
-  }
+  // A callback that triggers the timeout event manually
+  verto_continue_timeout_cb(verto_loop, verto_timer);
 }
 
 namespace {
@@ -543,7 +549,7 @@ int submit_request(HttpClient *client, const Headers &headers, Request *req) {
   req->req_nva = std::move(build_headers);
 
   if (expect_continue) {
-    auto timer = std::make_unique<ContinueTimer>(client->loop, req);
+    auto timer = std::make_unique<ContinueTimer>(client->verto_loop, req, client);
     req->continue_timer = std::move(timer);
   }
 
@@ -552,17 +558,8 @@ int submit_request(HttpClient *client, const Headers &headers, Request *req) {
 } // namespace
 
 namespace {
-void readcb(struct ev_loop *loop, ev_io *w, int revents) {
-  auto client = static_cast<HttpClient *>(w->data);
-  if (client->do_read() != 0) {
-    client->disconnect();
-  }
-}
-} // namespace
-
-namespace {
-void writecb(struct ev_loop *loop, ev_io *w, int revents) {
-  auto client = static_cast<HttpClient *>(w->data);
+void verto_writecb(verto_ctx *verto_loop, verto_ev *ev) {
+  auto client = static_cast<HttpClient *>(verto_get_private(ev));
   auto rv = client->do_write();
   if (rv == HttpClient::ERR_CONNECT_FAIL) {
     client->connect_fail();
@@ -575,30 +572,38 @@ void writecb(struct ev_loop *loop, ev_io *w, int revents) {
 } // namespace
 
 namespace {
-void timeoutcb(struct ev_loop *loop, ev_timer *w, int revents) {
-  auto client = static_cast<HttpClient *>(w->data);
-  std::cerr << "[ERROR] Timeout" << std::endl;
-  client->disconnect();
+void verto_readcb(verto_ctx *verto_loop, verto_ev *ev) {
+  auto client = static_cast<HttpClient *>(verto_get_private(ev));
+  
+  // In order to wait for the callback for the read event
+  // the write event observer was removed from the event loop in the previous step
+  // So now we need to add the read event observer into the event loop
+  verto_ev_flag write_flag = (verto_ev_flag)(VERTO_EV_FLAG_PERSIST | VERTO_EV_FLAG_IO_WRITE);
+  client->verto_wev = verto_add_io(client->verto_loop, write_flag, verto_writecb, client->fd);
+  verto_set_private(client->verto_wev, client, NULL);
+
+  if (client->do_read() != 0) {
+    client->disconnect();
+  }
 }
 } // namespace
 
 namespace {
-void settings_timeout_cb(struct ev_loop *loop, ev_timer *w, int revents) {
-  auto client = static_cast<HttpClient *>(w->data);
-  ev_timer_stop(loop, w);
+void verto_settings_timeout_cb(verto_ctx *verto_loop, verto_ev *ev) {
+  auto client = static_cast<HttpClient *>(verto_get_private(ev));
+  verto_del(ev);
 
   nghttp2_session_terminate_session(client->session, NGHTTP2_SETTINGS_TIMEOUT);
-
-  client->signal_write();
 }
 } // namespace
 
+
 HttpClient::HttpClient(const nghttp2_session_callbacks *callbacks,
-                       struct ev_loop *loop, SSL_CTX *ssl_ctx)
+                       verto_ctx *verto_loop, SSL_CTX *ssl_ctx)
     : wb(&mcpool),
       session(nullptr),
       callbacks(callbacks),
-      loop(loop),
+      verto_loop(verto_loop),
       ssl_ctx(ssl_ctx),
       ssl(nullptr),
       addrs(nullptr),
@@ -611,21 +616,6 @@ HttpClient::HttpClient(const nghttp2_session_callbacks *callbacks,
       upgrade_response_status_code(0),
       fd(-1),
       upgrade_response_complete(false) {
-  ev_io_init(&wev, writecb, 0, EV_WRITE);
-  ev_io_init(&rev, readcb, 0, EV_READ);
-
-  wev.data = this;
-  rev.data = this;
-
-  ev_timer_init(&wt, timeoutcb, 0., config.timeout);
-  ev_timer_init(&rt, timeoutcb, 0., config.timeout);
-
-  wt.data = this;
-  rt.data = this;
-
-  ev_timer_init(&settings_timer, settings_timeout_cb, 0., 10.);
-
-  settings_timer.data = this;
 }
 
 HttpClient::~HttpClient() {
@@ -742,12 +732,14 @@ int HttpClient::initiate_connection() {
     on_writefn = &HttpClient::on_write;
   }
 
-  ev_io_set(&rev, fd, EV_READ);
-  ev_io_set(&wev, fd, EV_WRITE);
-
-  ev_io_start(loop, &wev);
+  // Add read event observers and write event observers to the event loop
+  verto_ev_flag read_flag = (verto_ev_flag)(VERTO_EV_FLAG_PERSIST | VERTO_EV_FLAG_IO_READ);
+  verto_rev = verto_add_io(verto_loop, read_flag, verto_readcb, fd);
+  verto_set_private(verto_rev, this, NULL);
 
-  ev_timer_again(loop, &wt);
+  verto_ev_flag write_flag = (verto_ev_flag)(VERTO_EV_FLAG_PERSIST | VERTO_EV_FLAG_IO_WRITE);
+  verto_wev = verto_add_io(verto_loop, write_flag, verto_writecb, fd);
+  verto_set_private(verto_wev, this, NULL);
 
   return 0;
 }
@@ -761,13 +753,8 @@ void HttpClient::disconnect() {
     }
   }
 
-  ev_timer_stop(loop, &settings_timer);
-
-  ev_timer_stop(loop, &rt);
-  ev_timer_stop(loop, &wt);
-
-  ev_io_stop(loop, &rev);
-  ev_io_stop(loop, &wev);
+  // Exit the event loop
+  verto_break(verto_loop);
 
   nghttp2_session_del(session);
   session = nullptr;
@@ -788,8 +775,6 @@ void HttpClient::disconnect() {
 }
 
 int HttpClient::read_clear() {
-  ev_timer_again(loop, &rt);
-
   std::array<uint8_t, 8_k> buf;
 
   for (;;) {
@@ -816,8 +801,6 @@ int HttpClient::read_clear() {
 }
 
 int HttpClient::write_clear() {
-  ev_timer_again(loop, &rt);
-
   std::array<struct iovec, 2> iov;
 
   for (;;) {
@@ -836,8 +819,6 @@ int HttpClient::write_clear() {
       ;
     if (nwrite == -1) {
       if (errno == EAGAIN || errno == EWOULDBLOCK) {
-        ev_io_start(loop, &wev);
-        ev_timer_again(loop, &wt);
         return 0;
       }
       return -1;
@@ -846,9 +827,6 @@ int HttpClient::write_clear() {
     wb.drain(nwrite);
   }
 
-  ev_io_stop(loop, &wev);
-  ev_timer_stop(loop, &wt);
-
   return 0;
 }
 
@@ -883,12 +861,6 @@ int HttpClient::connected() {
 
   state = ClientState::CONNECTED;
 
-  ev_io_start(loop, &rev);
-  ev_io_stop(loop, &wev);
-
-  ev_timer_again(loop, &rt);
-  ev_timer_stop(loop, &wt);
-
   if (ssl) {
     SSL_set_fd(ssl, fd);
 
@@ -1046,8 +1018,6 @@ int HttpClient::on_upgrade_connect() {
 
   on_writefn = &HttpClient::noop;
 
-  signal_write();
-
   return 0;
 }
 
@@ -1236,7 +1206,9 @@ int HttpClient::connection_made() {
     }
   }
 
-  ev_timer_again(loop, &settings_timer);
+  // Add a settings timer and set the timeout to 10 seconds 
+  verto_settings_timer = verto_add_timeout(verto_loop, VERTO_EV_FLAG_PERSIST, verto_settings_timeout_cb, 10 *1000);
+  verto_set_private(verto_settings_timer, this, NULL);
 
   if (config.connection_window_bits != -1) {
     int32_t window_size = (1 << config.connection_window_bits) - 1;
@@ -1255,11 +1227,10 @@ int HttpClient::connection_made() {
     }
   }
 
-  signal_write();
-
   return 0;
 }
 
+
 int HttpClient::on_read(const uint8_t *data, size_t len) {
   if (config.hexdump) {
     util::hexdump(stdout, data, len);
@@ -1279,18 +1250,20 @@ int HttpClient::on_read(const uint8_t *data, size_t len) {
     return -1;
   }
 
-  signal_write();
-
   return 0;
 }
 
 int HttpClient::on_write() {
+  if (session == NULL)
+    return 0;
+
   for (;;) {
     if (wb.rleft() >= 16384) {
       return 0;
     }
 
     const uint8_t *data;
+
     auto len = nghttp2_session_mem_send(session, &data);
     if (len < 0) {
       std::cerr << "[ERROR] nghttp2_session_send() returned error: "
@@ -1314,8 +1287,6 @@ int HttpClient::on_write() {
 }
 
 int HttpClient::tls_handshake() {
-  ev_timer_again(loop, &rt);
-
   ERR_clear_error();
 
   auto rv = SSL_do_handshake(ssl);
@@ -1323,22 +1294,19 @@ int HttpClient::tls_handshake() {
   if (rv <= 0) {
     auto err = SSL_get_error(ssl, rv);
     switch (err) {
-    case SSL_ERROR_WANT_READ:
-      ev_io_stop(loop, &wev);
-      ev_timer_stop(loop, &wt);
+    case SSL_ERROR_WANT_READ: {
+      // Remove the write observer  
+      // add it to the event loop inside the read event callback
+      verto_del(verto_wev);
       return 0;
+    }
     case SSL_ERROR_WANT_WRITE:
-      ev_io_start(loop, &wev);
-      ev_timer_again(loop, &wt);
       return 0;
     default:
       return -1;
     }
   }
 
-  ev_io_stop(loop, &wev);
-  ev_timer_stop(loop, &wt);
-
   readfn = &HttpClient::read_tls;
   writefn = &HttpClient::write_tls;
 
@@ -1358,8 +1326,6 @@ int HttpClient::tls_handshake() {
 }
 
 int HttpClient::read_tls() {
-  ev_timer_again(loop, &rt);
-
   ERR_clear_error();
 
   std::array<uint8_t, 8_k> buf;
@@ -1386,8 +1352,6 @@ int HttpClient::read_tls() {
 }
 
 int HttpClient::write_tls() {
-  ev_timer_again(loop, &rt);
-
   ERR_clear_error();
 
   struct iovec iov;
@@ -1400,6 +1364,8 @@ int HttpClient::write_tls() {
     auto iovcnt = wb.riovec(&iov, 1);
 
     if (iovcnt == 0) {
+      // iovcnt == 0 indicates that the write event is no longer needed
+      verto_del(verto_wev);      
       break;
     }
 
@@ -1412,8 +1378,6 @@ int HttpClient::write_tls() {
         // renegotiation started
         return -1;
       case SSL_ERROR_WANT_WRITE:
-        ev_io_start(loop, &wev);
-        ev_timer_again(loop, &wt);
         return 0;
       default:
         return -1;
@@ -1422,15 +1386,9 @@ int HttpClient::write_tls() {
 
     wb.drain(rv);
   }
-
-  ev_io_stop(loop, &wev);
-  ev_timer_stop(loop, &wt);
-
   return 0;
 }
 
-void HttpClient::signal_write() { ev_io_start(loop, &wev); }
-
 bool HttpClient::all_requests_processed() const {
   return complete == reqvec.size();
 }
@@ -2033,7 +1991,8 @@ int on_frame_recv_callback2(nghttp2_session *session,
     if ((frame->hd.flags & NGHTTP2_FLAG_ACK) == 0) {
       break;
     }
-    ev_timer_stop(client->loop, &client->settings_timer);
+    //ev_timer_stop(client->loop, &client->settings_timer);
+    //verto_del(client->verto_settings_timer);
     break;
   case NGHTTP2_PUSH_PROMISE: {
     auto req = static_cast<Request *>(nghttp2_session_get_stream_user_data(
@@ -2286,7 +2245,9 @@ int communicate(
         requests,
     const nghttp2_session_callbacks *callbacks) {
   int result = 0;
-  auto loop = EV_DEFAULT;
+  // Create an event loop for libverto
+  auto loop = verto_new(NULL, VERTO_EV_TYPE_NONE);
+
   SSL_CTX *ssl_ctx = nullptr;
   if (scheme == "https") {
     ssl_ctx = SSL_CTX_new(TLS_client_method());
@@ -2393,10 +2354,9 @@ int communicate(
                 << std::endl;
       goto fin;
     }
-
-    ev_set_userdata(loop, &client);
-    ev_run(loop, 0);
-    ev_set_userdata(loop, nullptr);
+    
+    // Start running the event loop
+    verto_run(loop);
 
 #ifdef HAVE_JANSSON
     if (!config.harfile.empty()) {
@@ -3158,7 +3118,7 @@ int main(int argc, char **argv) {
 }
 
 } // namespace nghttp2
-
+ 
 int main(int argc, char **argv) {
   return nghttp2::run_app(nghttp2::main, argc, argv);
 }
diff --git a/src/nghttp.h b/src/nghttp.h
index a880414..3a80144 100644
--- a/src/nghttp.h
+++ b/src/nghttp.h
@@ -1,4 +1,4 @@
-/*
+ /*
  * nghttp2 - HTTP/2 C Library
  *
  * Copyright (c) 2015 Tatsuhiro Tsujikawa
@@ -34,7 +34,7 @@
 #ifdef HAVE_NETDB_H
 #  include <netdb.h>
 #endif // HAVE_NETDB_H
-
+ 
 #include <string>
 #include <vector>
 #include <set>
@@ -43,7 +43,7 @@
 
 #include <openssl/ssl.h>
 
-#include <ev.h>
+#include <verto-module.h>
 
 #include <nghttp2/nghttp2.h>
 
@@ -80,7 +80,7 @@ struct Config {
   ssize_t peer_max_concurrent_streams;
   int multiply;
   // milliseconds
-  ev_tstamp timeout;
+  double timeout;
   int window_bits;
   int connection_window_bits;
   int verbose;
@@ -118,9 +118,10 @@ struct RequestTiming {
 };
 
 struct Request; // forward declaration for ContinueTimer
+struct HttpClient;
 
 struct ContinueTimer {
-  ContinueTimer(struct ev_loop *loop, Request *req);
+  ContinueTimer(verto_ctx *verto_loop, Request *req, HttpClient *client);
   ~ContinueTimer();
 
   void start();
@@ -130,8 +131,10 @@ struct ContinueTimer {
   // callback has not already been run
   void dispatch_continue();
 
-  struct ev_loop *loop;
-  ev_timer timer;
+  verto_ctx *verto_loop;
+  verto_ev *verto_timer;
+
+  Request *req;
 };
 
 struct Request {
@@ -192,6 +195,8 @@ struct Request {
   bool expect_final_response;
   // only assigned if this request is using Expect/Continue
   std::unique_ptr<ContinueTimer> continue_timer;
+  // Pointer to the current Client
+  HttpClient *client;
 };
 
 struct SessionTiming {
@@ -212,7 +217,7 @@ struct SessionTiming {
 enum class ClientState { IDLE, CONNECTED };
 
 struct HttpClient {
-  HttpClient(const nghttp2_session_callbacks *callbacks, struct ev_loop *loop,
+  HttpClient(const nghttp2_session_callbacks *callbacks, verto_ctx *verto_loop,
              SSL_CTX *ssl_ctx);
   ~HttpClient();
 
@@ -220,7 +225,7 @@ struct HttpClient {
   int resolve_host(const std::string &host, uint16_t port);
   int initiate_connection();
   void disconnect();
-
+ 
   int noop();
   int read_clear();
   int write_clear();
@@ -241,8 +246,6 @@ struct HttpClient {
   void connect_fail();
   void request_done(Request *req);
 
-  void signal_write();
-
   bool all_requests_processed() const;
   void update_hostport();
   bool add_request(const std::string &uri,
@@ -269,17 +272,19 @@ struct HttpClient {
   // Used for parse the HTTP upgrade response from server
   std::unique_ptr<llhttp_t> htp;
   SessionTiming timing;
-  ev_io wev;
-  ev_io rev;
-  ev_timer wt;
-  ev_timer rt;
-  ev_timer settings_timer;
+  // An observer for reading events
+  verto_ev *verto_wev;
+  // An observer for writing events
+  verto_ev *verto_rev;
+  // An observer for timeout events
+  verto_ev *verto_settings_timer;
   std::function<int(HttpClient &)> readfn, writefn;
   std::function<int(HttpClient &, const uint8_t *, size_t)> on_readfn;
   std::function<int(HttpClient &)> on_writefn;
   nghttp2_session *session;
   const nghttp2_session_callbacks *callbacks;
-  struct ev_loop *loop;
+  // The event loop for the nghttp client
+  verto_ctx *verto_loop;
   SSL_CTX *ssl_ctx;
   SSL *ssl;
   addrinfo *addrs;
-- 
2.33.0

